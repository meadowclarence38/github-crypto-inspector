/**
 * AI/ML Code Detection Analyzer
 * Detects patterns indicative of AI-generated code
 */

import { Octokit } from "@octokit/rest";

export interface AICodeAnalysisResult {
  aiGeneratedScore: number; // 0-100, higher = more likely AI-generated
  filesAnalyzed: number;
  aiIndicators: {
    aiSignatures: number; // Files with explicit AI markers
    suspiciousPatterns: number; // Files with AI-like patterns
    genericNaming: number; // Generic variable/function names
    verboseComments: number; // Overly verbose comments
    boilerplateHeavy: number; // Excessive boilerplate
  };
  detectedFiles: Array<{
    path: string;
    confidence: number; // 0-100
    reasons: string[];
  }>;
  flags: string[];
  recommendations: string[];
}

// AI code markers and patterns
const AI_SIGNATURES = [
  /generated by (chatgpt|gpt|claude|copilot|ai|artificial intelligence)/i,
  /ai[-\s]?(generated|assisted|created|written)/i,
  /@(chatgpt|copilot|ai-generated)/i,
  /this code (was|is) (generated|created|written) (by|using) (ai|chatgpt|claude|copilot)/i,
  /\/\/ (chatgpt|claude|copilot|ai):/i,
];

const GENERIC_PATTERNS = {
  // Generic variable names (very common in AI code)
  variables: /\b(result|data|temp|value|item|obj|arr|str|num|flag|status|response|request)\b/g,
  
  // Generic function names
  functions: /\b(handleClick|handleSubmit|handleChange|processData|getData|setData|updateValue|doSomething|performAction)\b/g,
  
  // Overly verbose comments (AI loves explaining obvious things)
  verboseComments: /\/\/ (This (function|method|class)|Initialize|Create|Set|Get|Update|Delete|Handle|Process) .{40,}/g,
  
  // TODO/FIXME/NOTE patterns (AI often adds these)
  todoPatterns: /\/\/ (TODO|FIXME|NOTE|HACK|XXX):/gi,
};

const BOILERPLATE_INDICATORS = [
  // Excessive try-catch blocks
  /try\s*\{[^}]*\}\s*catch\s*\([^)]*\)\s*\{[^}]*console\.(log|error)/g,
  
  // Generic error messages
  /(error|failed|something went wrong|an error occurred|unexpected error)/i,
  
  // Perfect formatting but simple logic
  /^(\s{2}|\t)(\s{2}|\t)(\s{2}|\t)/gm, // 3+ levels of indentation
];

export async function analyzeAICode(
  octokit: Octokit,
  owner: string,
  repo: string
): Promise<AICodeAnalysisResult> {
  const result: AICodeAnalysisResult = {
    aiGeneratedScore: 0,
    filesAnalyzed: 0,
    aiIndicators: {
      aiSignatures: 0,
      suspiciousPatterns: 0,
      genericNaming: 0,
      verboseComments: 0,
      boilerplateHeavy: 0,
    },
    detectedFiles: [],
    flags: [],
    recommendations: [],
  };

  try {
    // Get repository tree (all files)
    const { data: tree } = await octokit.repos.getContent({
      owner,
      repo,
      path: "",
    });

    if (!Array.isArray(tree)) return result;

    // Filter for source code files
    const codeFiles = tree.filter((file) => 
      file.type === "file" && 
      /\.(js|ts|jsx|tsx|py|rs|sol|go|java|cpp|c|h)$/i.test(file.name)
    );

    // Limit to 20 files to avoid rate limits
    const filesToAnalyze = codeFiles.slice(0, 20);
    result.filesAnalyzed = filesToAnalyze.length;

    // Analyze each file
    for (const file of filesToAnalyze) {
      try {
        const { data: fileData } = await octokit.repos.getContent({
          owner,
          repo,
          path: file.path,
        });

        if ("content" in fileData && fileData.content) {
          const content = Buffer.from(fileData.content, "base64").toString("utf-8");
          const analysis = analyzeFileContent(content, file.path);
          
          if (analysis.isAIGenerated) {
            result.detectedFiles.push({
              path: file.path,
              confidence: analysis.confidence,
              reasons: analysis.reasons,
            });
          }

          // Aggregate indicators
          if (analysis.hasAISignature) result.aiIndicators.aiSignatures++;
          if (analysis.hasSuspiciousPatterns) result.aiIndicators.suspiciousPatterns++;
          if (analysis.hasGenericNaming) result.aiIndicators.genericNaming++;
          if (analysis.hasVerboseComments) result.aiIndicators.verboseComments++;
          if (analysis.isBoilerplateHeavy) result.aiIndicators.boilerplateHeavy++;
        }
      } catch (err) {
        // Skip files that can't be fetched (too large, binary, etc.)
        continue;
      }
    }

    // Calculate AI-generated score
    result.aiGeneratedScore = calculateAIScore(result, filesToAnalyze.length);

    // Generate flags and recommendations
    if (result.aiGeneratedScore >= 70) {
      result.flags.push("High likelihood of AI-generated code (70%+)");
      result.flags.push("Multiple files show AI patterns and signatures");
      result.recommendations.push("Review code quality manually - AI-generated code may lack optimization");
      result.recommendations.push("Check for copied code from tutorials or documentation");
    } else if (result.aiGeneratedScore >= 40) {
      result.flags.push("Moderate AI code patterns detected");
      result.recommendations.push("Some files may be AI-assisted - verify critical logic");
    } else if (result.aiGeneratedScore >= 20) {
      result.recommendations.push("Minor AI assistance detected - likely acceptable");
    } else {
      result.recommendations.push("Code appears to be human-written with minimal AI assistance");
    }

    if (result.aiIndicators.aiSignatures > 0) {
      result.flags.push(`Found ${result.aiIndicators.aiSignatures} file(s) with explicit AI markers`);
    }

    if (result.aiIndicators.genericNaming > filesToAnalyze.length * 0.5) {
      result.flags.push("Excessive generic naming patterns (common in AI code)");
    }

  } catch (err) {
    console.error("AI code analysis error:", err);
    result.flags.push("Could not complete AI code analysis");
  }

  return result;
}

function analyzeFileContent(content: string, filePath: string): {
  isAIGenerated: boolean;
  confidence: number;
  reasons: string[];
  hasAISignature: boolean;
  hasSuspiciousPatterns: boolean;
  hasGenericNaming: boolean;
  hasVerboseComments: boolean;
  isBoilerplateHeavy: boolean;
} {
  const reasons: string[] = [];
  let confidence = 0;

  // Check for explicit AI signatures
  const hasAISignature = AI_SIGNATURES.some((pattern) => pattern.test(content));
  if (hasAISignature) {
    confidence += 40;
    reasons.push("Explicit AI generation marker found");
  }

  // Check for generic naming patterns
  const genericVarMatches = content.match(GENERIC_PATTERNS.variables) || [];
  const genericFuncMatches = content.match(GENERIC_PATTERNS.functions) || [];
  const hasGenericNaming = (genericVarMatches.length + genericFuncMatches.length) > 15;
  
  if (hasGenericNaming) {
    confidence += 15;
    reasons.push(`Excessive generic naming (${genericVarMatches.length + genericFuncMatches.length} instances)`);
  }

  // Check for verbose comments
  const verboseCommentMatches = content.match(GENERIC_PATTERNS.verboseComments) || [];
  const hasVerboseComments = verboseCommentMatches.length > 10;
  
  if (hasVerboseComments) {
    confidence += 10;
    reasons.push(`Overly verbose comments (${verboseCommentMatches.length} instances)`);
  }

  // Check for TODO/FIXME patterns
  const todoMatches = content.match(GENERIC_PATTERNS.todoPatterns) || [];
  if (todoMatches.length > 5) {
    confidence += 5;
    reasons.push(`Many TODO markers (${todoMatches.length})`);
  }

  // Check for boilerplate patterns
  let boilerplateScore = 0;
  BOILERPLATE_INDICATORS.forEach((pattern) => {
    const matches = content.match(pattern) || [];
    boilerplateScore += matches.length;
  });
  
  const isBoilerplateHeavy = boilerplateScore > 10;
  if (isBoilerplateHeavy) {
    confidence += 10;
    reasons.push("Excessive boilerplate code");
  }

  // Check comment-to-code ratio (AI tends to over-comment)
  const lines = content.split("\n");
  const commentLines = lines.filter((line) => 
    line.trim().startsWith("//") || 
    line.trim().startsWith("#") ||
    line.trim().startsWith("/*") ||
    line.trim().startsWith("*")
  ).length;
  
  const commentRatio = commentLines / lines.length;
  if (commentRatio > 0.3) {
    confidence += 10;
    reasons.push(`High comment ratio (${(commentRatio * 100).toFixed(1)}%)`);
  }

  // Check for perfect formatting (AI loves consistency)
  const hasConsistentIndentation = /^(\s{2}|\s{4}|\t)/gm.test(content);
  const hasNoTrailingWhitespace = !/ +$/gm.test(content);
  
  if (hasConsistentIndentation && hasNoTrailingWhitespace && content.length > 500) {
    confidence += 5;
    reasons.push("Perfect formatting (unusual in human code)");
  }

  // Detect suspicious patterns (specific to crypto)
  const hasSuspiciousPatterns = 
    /\/\/ (ERC-20|Token|Standard) (implementation|contract)/i.test(content) ||
    /\/\/ (This is a|Simple) (basic )?(token|contract|implementation)/i.test(content);
  
  if (hasSuspiciousPatterns) {
    confidence += 10;
    reasons.push("Generic crypto template comments");
  }

  const isAIGenerated = confidence >= 30;

  return {
    isAIGenerated,
    confidence: Math.min(confidence, 100),
    reasons,
    hasAISignature,
    hasSuspiciousPatterns,
    hasGenericNaming,
    hasVerboseComments,
    isBoilerplateHeavy,
  };
}

function calculateAIScore(result: AICodeAnalysisResult, totalFiles: number): number {
  if (totalFiles === 0) return 0;

  // Weight different indicators
  let score = 0;

  // Explicit AI signatures are the strongest indicator
  score += (result.aiIndicators.aiSignatures / totalFiles) * 50;

  // Suspicious patterns
  score += (result.aiIndicators.suspiciousPatterns / totalFiles) * 20;

  // Generic naming
  score += (result.aiIndicators.genericNaming / totalFiles) * 15;

  // Verbose comments
  score += (result.aiIndicators.verboseComments / totalFiles) * 10;

  // Boilerplate
  score += (result.aiIndicators.boilerplateHeavy / totalFiles) * 5;

  return Math.min(Math.round(score), 100);
}
